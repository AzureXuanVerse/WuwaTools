// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace WWParser.Defs
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public struct AkiMap : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static AkiMap GetRootAsAkiMap(ByteBuffer _bb) { return GetRootAsAkiMap(_bb, new AkiMap()); }
  public static AkiMap GetRootAsAkiMap(ByteBuffer _bb, AkiMap obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AkiMap __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int MapId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public string MapName { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMapNameBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetMapNameBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetMapNameArray() { return __p.__vector_as_array<byte>(6); }
  public int FatherMap { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int GroupMark { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Floor { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public string SwitchCondition { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSwitchConditionBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetSwitchConditionBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetSwitchConditionArray() { return __p.__vector_as_array<byte>(14); }
  public string MapPic3d { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMapPic3dBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetMapPic3dBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetMapPic3dArray() { return __p.__vector_as_array<byte>(16); }
  public string MapPic2d { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMapPic2dBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetMapPic2dBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetMapPic2dArray() { return __p.__vector_as_array<byte>(18); }
  public int BigMapDefaultScale { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BigMapMinScale { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BigMapMaxScale { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int LittleMapDefaultScale { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public string LimitContent { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLimitContentBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetLimitContentBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetLimitContentArray() { return __p.__vector_as_array<byte>(28); }
  public bool IsGravityMap { get { int o = __p.__offset(30); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<WWParser.Defs.AkiMap> CreateAkiMap(FlatBufferBuilder builder,
      int map_id = 0,
      StringOffset map_nameOffset = default(StringOffset),
      int father_map = 0,
      int group_mark = 0,
      int floor = 0,
      StringOffset switch_conditionOffset = default(StringOffset),
      StringOffset map_pic3dOffset = default(StringOffset),
      StringOffset map_pic2dOffset = default(StringOffset),
      int big_map_default_scale = 0,
      int big_map_min_scale = 0,
      int big_map_max_scale = 0,
      int little_map_default_scale = 0,
      StringOffset limit_contentOffset = default(StringOffset),
      bool is_gravity_map = false) {
    builder.StartTable(14);
    AkiMap.AddLimitContent(builder, limit_contentOffset);
    AkiMap.AddLittleMapDefaultScale(builder, little_map_default_scale);
    AkiMap.AddBigMapMaxScale(builder, big_map_max_scale);
    AkiMap.AddBigMapMinScale(builder, big_map_min_scale);
    AkiMap.AddBigMapDefaultScale(builder, big_map_default_scale);
    AkiMap.AddMapPic2d(builder, map_pic2dOffset);
    AkiMap.AddMapPic3d(builder, map_pic3dOffset);
    AkiMap.AddSwitchCondition(builder, switch_conditionOffset);
    AkiMap.AddFloor(builder, floor);
    AkiMap.AddGroupMark(builder, group_mark);
    AkiMap.AddFatherMap(builder, father_map);
    AkiMap.AddMapName(builder, map_nameOffset);
    AkiMap.AddMapId(builder, map_id);
    AkiMap.AddIsGravityMap(builder, is_gravity_map);
    return AkiMap.EndAkiMap(builder);
  }

  public static void StartAkiMap(FlatBufferBuilder builder) { builder.StartTable(14); }
  public static void AddMapId(FlatBufferBuilder builder, int mapId) { builder.AddInt(0, mapId, 0); }
  public static void AddMapName(FlatBufferBuilder builder, StringOffset mapNameOffset) { builder.AddOffset(1, mapNameOffset.Value, 0); }
  public static void AddFatherMap(FlatBufferBuilder builder, int fatherMap) { builder.AddInt(2, fatherMap, 0); }
  public static void AddGroupMark(FlatBufferBuilder builder, int groupMark) { builder.AddInt(3, groupMark, 0); }
  public static void AddFloor(FlatBufferBuilder builder, int floor) { builder.AddInt(4, floor, 0); }
  public static void AddSwitchCondition(FlatBufferBuilder builder, StringOffset switchConditionOffset) { builder.AddOffset(5, switchConditionOffset.Value, 0); }
  public static void AddMapPic3d(FlatBufferBuilder builder, StringOffset mapPic3dOffset) { builder.AddOffset(6, mapPic3dOffset.Value, 0); }
  public static void AddMapPic2d(FlatBufferBuilder builder, StringOffset mapPic2dOffset) { builder.AddOffset(7, mapPic2dOffset.Value, 0); }
  public static void AddBigMapDefaultScale(FlatBufferBuilder builder, int bigMapDefaultScale) { builder.AddInt(8, bigMapDefaultScale, 0); }
  public static void AddBigMapMinScale(FlatBufferBuilder builder, int bigMapMinScale) { builder.AddInt(9, bigMapMinScale, 0); }
  public static void AddBigMapMaxScale(FlatBufferBuilder builder, int bigMapMaxScale) { builder.AddInt(10, bigMapMaxScale, 0); }
  public static void AddLittleMapDefaultScale(FlatBufferBuilder builder, int littleMapDefaultScale) { builder.AddInt(11, littleMapDefaultScale, 0); }
  public static void AddLimitContent(FlatBufferBuilder builder, StringOffset limitContentOffset) { builder.AddOffset(12, limitContentOffset.Value, 0); }
  public static void AddIsGravityMap(FlatBufferBuilder builder, bool isGravityMap) { builder.AddBool(13, isGravityMap, false); }
  public static Offset<WWParser.Defs.AkiMap> EndAkiMap(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<WWParser.Defs.AkiMap>(o);
  }
  public AkiMapT UnPack() {
    var _o = new AkiMapT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(AkiMapT _o) {
    _o.MapId = this.MapId;
    _o.MapName = this.MapName;
    _o.FatherMap = this.FatherMap;
    _o.GroupMark = this.GroupMark;
    _o.Floor = this.Floor;
    _o.SwitchCondition = this.SwitchCondition;
    _o.MapPic3d = this.MapPic3d;
    _o.MapPic2d = this.MapPic2d;
    _o.BigMapDefaultScale = this.BigMapDefaultScale;
    _o.BigMapMinScale = this.BigMapMinScale;
    _o.BigMapMaxScale = this.BigMapMaxScale;
    _o.LittleMapDefaultScale = this.LittleMapDefaultScale;
    _o.LimitContent = this.LimitContent;
    _o.IsGravityMap = this.IsGravityMap;
  }
  public static Offset<WWParser.Defs.AkiMap> Pack(FlatBufferBuilder builder, AkiMapT _o) {
    if (_o == null) return default(Offset<WWParser.Defs.AkiMap>);
    var _map_name = _o.MapName == null ? default(StringOffset) : builder.CreateString(_o.MapName);
    var _switch_condition = _o.SwitchCondition == null ? default(StringOffset) : builder.CreateString(_o.SwitchCondition);
    var _map_pic3d = _o.MapPic3d == null ? default(StringOffset) : builder.CreateString(_o.MapPic3d);
    var _map_pic2d = _o.MapPic2d == null ? default(StringOffset) : builder.CreateString(_o.MapPic2d);
    var _limit_content = _o.LimitContent == null ? default(StringOffset) : builder.CreateString(_o.LimitContent);
    return CreateAkiMap(
      builder,
      _o.MapId,
      _map_name,
      _o.FatherMap,
      _o.GroupMark,
      _o.Floor,
      _switch_condition,
      _map_pic3d,
      _map_pic2d,
      _o.BigMapDefaultScale,
      _o.BigMapMinScale,
      _o.BigMapMaxScale,
      _o.LittleMapDefaultScale,
      _limit_content,
      _o.IsGravityMap);
  }
}

public class AkiMapT
{
  [Newtonsoft.Json.JsonProperty("map_id")]
  public int MapId { get; set; }
  [Newtonsoft.Json.JsonProperty("map_name")]
  public string MapName { get; set; }
  [Newtonsoft.Json.JsonProperty("father_map")]
  public int FatherMap { get; set; }
  [Newtonsoft.Json.JsonProperty("group_mark")]
  public int GroupMark { get; set; }
  [Newtonsoft.Json.JsonProperty("floor")]
  public int Floor { get; set; }
  [Newtonsoft.Json.JsonProperty("switch_condition")]
  public string SwitchCondition { get; set; }
  [Newtonsoft.Json.JsonProperty("map_pic3d")]
  public string MapPic3d { get; set; }
  [Newtonsoft.Json.JsonProperty("map_pic2d")]
  public string MapPic2d { get; set; }
  [Newtonsoft.Json.JsonProperty("big_map_default_scale")]
  public int BigMapDefaultScale { get; set; }
  [Newtonsoft.Json.JsonProperty("big_map_min_scale")]
  public int BigMapMinScale { get; set; }
  [Newtonsoft.Json.JsonProperty("big_map_max_scale")]
  public int BigMapMaxScale { get; set; }
  [Newtonsoft.Json.JsonProperty("little_map_default_scale")]
  public int LittleMapDefaultScale { get; set; }
  [Newtonsoft.Json.JsonProperty("limit_content")]
  public string LimitContent { get; set; }
  [Newtonsoft.Json.JsonProperty("is_gravity_map")]
  public bool IsGravityMap { get; set; }

  public AkiMapT() {
    this.MapId = 0;
    this.MapName = null;
    this.FatherMap = 0;
    this.GroupMark = 0;
    this.Floor = 0;
    this.SwitchCondition = null;
    this.MapPic3d = null;
    this.MapPic2d = null;
    this.BigMapDefaultScale = 0;
    this.BigMapMinScale = 0;
    this.BigMapMaxScale = 0;
    this.LittleMapDefaultScale = 0;
    this.LimitContent = null;
    this.IsGravityMap = false;
  }
}


static public class AkiMapVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*MapId*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 6 /*MapName*/, false)
      && verifier.VerifyField(tablePos, 8 /*FatherMap*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*GroupMark*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Floor*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 14 /*SwitchCondition*/, false)
      && verifier.VerifyString(tablePos, 16 /*MapPic3d*/, false)
      && verifier.VerifyString(tablePos, 18 /*MapPic2d*/, false)
      && verifier.VerifyField(tablePos, 20 /*BigMapDefaultScale*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 22 /*BigMapMinScale*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 24 /*BigMapMaxScale*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 26 /*LittleMapDefaultScale*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 28 /*LimitContent*/, false)
      && verifier.VerifyField(tablePos, 30 /*IsGravityMap*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
